// import Trap from "./Trap.js";

// export default class DynamiqueTrap extends Trap {
//     constructor(x1, y1, x2, y2, w, h, couleur, vitesse, t0, t1, t2) {
//         super(x1, y1, w, h, couleur);
//         this.x1 = x1;
//         this.y1 = y1;
//         this.x2 = x2;
//         this.y2 = y2;
//         this.vitesse = vitesse;
//         this.t0 = t0; //commencer après x millisecond
//         this.t1 = t1; //temps attente départ
//         this.t2 = t2; //temps attente retour

//         this.t = 0; // Paramètre t pour la position sur la droite
//         this.direction = 1; // 1 pour aller de x1,y1 à x2,y2, -1 pour l'inverse

//         this.startTime = Date.now(); // Enregistre l'heure actuelle en millisecondes
//     }

//     update() {
//         const elapsedTime = Date.now() - this.startTime; // Temps écoulé depuis le début de l'animation

//         // Si 3 secondes se sont écoulées, commencer à déplacer le piège
//         if (elapsedTime >= this.t0) {
//             // Calcul des nouvelles coordonnées en fonction du paramètre t
//             this.x = this.x1 + this.t * (this.x2 - this.x1);
//             this.y = this.y1 + this.t * (this.y2 - this.y1);

//             // Met à jour le paramètre t pour le prochain mouvement
//             this.t += this.vitesse * this.direction;

//             // Si on a atteint la fin de la ligne, on inverse la direction
//             if (this.t >= 1 || this.t <= 0) {
//                 this.direction *= -1; // Inverse la direction
//             }
//         }
//     }
// }








import Player from "./Player.js";
import Obstacle from "./Obstacle.js";
import Sortie from "./Sortie.js";
import Trap from "./Trap.js";
import DynamiqueTrap from "./DynamiqueTrap.js";
import { rectsOverlap } from "./collisions.js";
import { initListeners } from "./ecouteurs.js";

export default class Game {
    objetsGraphiques = [];

    constructor(canvas) {
        this.canvas = canvas;
        // etat du clavier
        this.inputStates = {
            mouseX: 0,
            mouseY: 0,
        };
    }

    async init(canvas) {
        this.ctx = this.canvas.getContext("2d");

        this.player = new Player(100, 100);
        this.objetsGraphiques.push(this.player);

        // On cree deux obstacles
        let obstacle1 = new Obstacle(300, 0, 40, 600, "red");
        this.objetsGraphiques.push(obstacle1);
        let obstacle3 = new Obstacle(500, 400, 50, 20, "red");
        this.objetsGraphiques.push(obstacle3);

        // On ajoute un piège
        let piege = new Trap(500, 500, 100, 100, "blue");
        this.objetsGraphiques.push(piege);

        // On ajoute un piège dynamique
        let piegeDynamique = new DynamiqueTrap(500, 300, 500, 100, 30, 30, "blue", 0.005,3000,0,0);
        this.objetsGraphiques.push(piegeDynamique);

        let piegeDynamique2 = new DynamiqueTrap(650, 500, 650, 750, 30, 30, "blue", 0.005, 0,1000,3000);
        this.objetsGraphiques.push(piegeDynamique2);

        // On ajoute la sortie
        // TODO
        let sortie = new Sortie(700, 700, 30, 30, "green");
        this.objetsGraphiques.push(sortie);

        // On initialise les écouteurs de touches, souris, etc.
        initListeners(this.inputStates, this.canvas);

        console.log("Game initialisé");
    }

    start() {
        console.log("Game démarré");

        // On démarre une animation à 60 images par seconde
        requestAnimationFrame(this.mainAnimationLoop.bind(this));
    }

    mainAnimationLoop() {
        // 1 - on efface le canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 2 - on dessine les objets à animer dans le jeu
        // ici on dessine le monstre
        this.drawAllObjects();

        // 3 - On regarde l'état du clavier, manette, souris et on met à jour
        // l'état des objets du jeu en conséquence
        this.update();

        // 4 - on demande au navigateur d'appeler la fonction mainAnimationLoop
        // à nouveau dans 1/60 de seconde
        requestAnimationFrame(this.mainAnimationLoop.bind(this));
    }

    drawAllObjects() {
        // Dessine tous les objets du jeu
        this.objetsGraphiques.forEach(obj => {
            obj.draw(this.ctx);
        });
    }

    update() {
        // Appelée par mainAnimationLoop
        // donc tous les 1/60 de seconde
        
        // Déplacement du joueur. 
        this.movePlayer();

        //Piège dynamique animation
        this.objetsGraphiques.forEach(obj => {
            if (obj instanceof DynamiqueTrap) {
                obj.update();
            }
        });
        
        // On regarde si le joueur a atteint la sortie
        // TODO

    }

    movePlayer() {
        this.player.vitesseX = 0;
        this.player.vitesseY = 0;
        
        if(this.inputStates.ArrowRight) {
            this.player.vitesseX = 3;
        } 
        if(this.inputStates.ArrowLeft) {
            this.player.vitesseX = -3;
        } 

        if(this.inputStates.ArrowUp) {
            this.player.vitesseY = -3;
        } 

        if(this.inputStates.ArrowDown) {
            this.player.vitesseY = 3;
        } 

        this.player.move();

        this.testCollisionsPlayer();
    }

    testCollisionsPlayer() {
        // Teste collision avec les bords du canvas
        this.testCollisionPlayerBordsEcran();

        // Teste collision avec les obstacles
        this.testCollisionPlayerObstacles();
       
    }

    testCollisionPlayerBordsEcran() {
        // Raoppel : le x, y du joueur est en son centre, pas dans le coin en haut à gauche!
        if(this.player.x - this.player.w/2 < 0) {
            // On stoppe le joueur
            this.player.vitesseX = 0;
            // on le remet au point de contaxct
            this.player.x = this.player.w/2;
        }
        if(this.player.x + this.player.w/2 > this.canvas.width) {
            this.player.vitesseX = 0;
            // on le remet au point de contact
            this.player.x = this.canvas.width - this.player.w/2;
        }

        if(this.player.y - this.player.h/2 < 0) {
            this.player.y = this.player.h/2;
            this.player.vitesseY = 0;

        }
       
        if(this.player.y + this.player.h/2 > this.canvas.height) {
            this.player.vitesseY = 0;
            this.player.y = this.canvas.height - this.player.h/2;
        }
    }

    testCollisionPlayerObstacles() {
        const pushBack = 0; // Distance supplémentaire pour repousser le joueur
        //pour le  moment on ne fait rien car pas de pb de collision

        this.objetsGraphiques.forEach(obj => {
            //Obstacle
            if (obj instanceof Obstacle) {
                if (rectsOverlap(
                    this.player.x - this.player.w / 2, this.player.y - this.player.h / 2, this.player.w, this.player.h,
                    obj.x, obj.y, obj.w, obj.h)) {
    
                    console.log("Collision avec obstacle");
    
                    // Vérifie la direction de la collision
                    let playerLeft = this.player.x - this.player.w / 2;
                    let playerRight = this.player.x + this.player.w / 2;
                    let playerTop = this.player.y - this.player.h / 2;
                    let playerBottom = this.player.y + this.player.h / 2;
    
                    let objLeft = obj.x;
                    let objRight = obj.x + obj.w;
                    let objTop = obj.y;
                    let objBottom = obj.y + obj.h;
    
                    let overlapLeft = playerRight - objLeft;
                    let overlapRight = objRight - playerLeft;
                    let overlapTop = playerBottom - objTop;
                    let overlapBottom = objBottom - playerTop;
    
                    let minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
    
                    if (minOverlap === overlapLeft) {
                        this.player.x = objLeft - this.player.w / 2 - pushBack; // Repousse à gauche
                    } else if (minOverlap === overlapRight) {
                        this.player.x = objRight + this.player.w / 2 + pushBack; // Repousse à droite
                    } else if (minOverlap === overlapTop) {
                        this.player.y = objTop - this.player.h / 2 - pushBack; // Repousse en haut
                    } else if (minOverlap === overlapBottom) {
                        this.player.y = objBottom + this.player.h / 2 + pushBack; // Repousse en bas
                    }
                    //Je vois pas l'inté"ret de cette ligne
                    // this.player.vitesseX = 0;
                    // this.player.vitesseY = 0;
                }
            }
            //Piège
            if(obj instanceof Trap) {
                if(rectsOverlap(this.player.x-this.player.w/2, this.player.y - this.player.h/2, this.player.w, this.player.h, obj.x, obj.y, obj.w, obj.h)) {
                    console.log("Piège you lose");
                    this.player.x = 100;
                    this.player.y = 100;
                }
            }
            //Sortie
            if(obj instanceof Sortie) {
                if(rectsOverlap(this.player.x-this.player.w/2, this.player.y - this.player.h/2, this.player.w, this.player.h, obj.x, obj.y, obj.w, obj.h)) {
                    console.log("Sortie atteinte");
                    this.player.x = 100;
                    this.player.y = 100;
                }
            }
        });
    }
    

}